## Week 2: Sysmon and Log Ingestion

Hey everyone! Welcome to Week 2 of the **30-Day SOC Analyst Challenge**. This week, I dove into **Sysmon** (a super useful Windows utility for monitoring events) and integrated it with **Kibana** to start ingesting logs. Along the way, I also set up **Elastic Agents** on an Ubuntu server, and I’ll be walking you through everything I did, why I did it, and give some helpful tips to make your life easier if you’re following along!

1. **Downloaded Sysmon onto Windows Server**  
   - I accessed the Windows Server using RDP (Remote Desktop Protocol) and installed Sysmon. Sysmon’s great for tracking down important security events in Windows systems.  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2022%20Downloaded%20Sysmon%20via%20RDP%20Connection.PNG)

2. **Added a Popular Sysmon Configuration (Olaf config)**  
   - To make Sysmon more powerful, I downloaded a well-known configuration by Olaf Hartong. This config provides a solid baseline of what to look for, which saved me a lot of time instead of manually configuring it from scratch. Highly recommend it!  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2023%20Popular%20config%20for%20sysmon%2C%20download%20this%20file%20to%20the%20sysmon%20folder!.PNG)

3. **Running Sysmon in PowerShell as an Administrator**  
   - Just a quick tip here: always remember to run Sysmon in PowerShell as an admin; otherwise, it won’t have the permissions needed to monitor everything properly.

4. **Verified Sysmon Installation Using Event Viewer**  
   - I made sure Sysmon was running by checking it in Event Viewer. This was a key step to ensure that I’m capturing the right logs.  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2024%20Successful%20Sysmon%20and%20install%20and%20seeing%20it%20in%20real%20time%20become%20a%20process.PNG)

5. **Opened Sysmon in Event Viewer to View Event IDs and Logs**  
   - This is where you’ll start seeing all the event IDs that Sysmon captures. Pretty satisfying!  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2025%20Just%20seeing%20the%20event%20IDs%20being%20generated%20by%20sysmon.PNG)

6. **Added Custom Windows Event Logs Integration on Kibana**  
   - To get these logs into Kibana, I had to add a custom Windows event logs integration. This way, Kibana can start ingesting everything from Sysmon.  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2025%20On%20kibana%2C%20go%20add%20the%20custom%20windows%20event%20logs%20integrations%20so%20we%20can%20ingest%20sysmon.PNG)

7. **Obtained the Channel Name for Sysmon**  
   - You need to get the channel name to specify which logs you want to ingest. For Sysmon, this was straightforward, but if you're working with other services, be sure to verify this step so you know you're ingesting the correct logs.  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2026%20Get%20your%20channel%20name%20so%20you%20can%20fill%20in%20info%20when%20adding%20custom%20windows%20event%20logs.PNG)

8. **Entered Necessary Information for Sysmon Logs Integration**  
   - I filled in the details for the Sysmon integration. At this point, Kibana was ready to start collecting the logs generated by Sysmon.  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2027%20Enter%20info%20for%20sysmon%20event%20log%20integration.PNG)

9. **Added Sysmon Configuration to Existing Policy**  
   - A quick tip here: make sure you add your Sysmon configuration to your existing policy. This ensures everything works together seamlessly in your project!  
   ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2028%20add%20to%20your%20existing%20policy%20for%20the%20project.PNG)

10. **Configured Windows Defender to Log Specific Events**  
    - I narrowed down the logs I was looking for to specific event IDs like 1116, 1117, and 5001. Otherwise, Windows Defender can generate a TON of logs you might not need, so this helped cut down on the noise.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2029%20same%20process%20as%20sysmon%20for%20defender%2C%20but%20add%20specific%20event%20IDs%20you%20find%20important%20on%20the%20documentation.PNG)

11. **Verified Active Policies**  
    - It’s always good to double-check that your policies are up and running after making these changes.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2030%20Verify%20policies%20are%20now%20up%20and%20running.PNG)

12. **Troubleshooting: No Logs Initially Received**  
    - At first, I wasn’t receiving any logs, which was frustrating, but it turned out I needed to adjust the firewall settings.

13. **Adjusted Firewall Policy in Vultr to Allow Port 9200**  
    - To solve the issue, I opened up port 9200. This allowed the logs to flow freely into Kibana.

14. **Successful Log Retrieval!**  
    - Finally, the logs started coming in! It’s a good feeling when everything is working smoothly after a little troubleshooting.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2031%20We%20got%20logs!.PNG)

15. **Spun Up a Linux Server**  
    - I decided to spin up a Linux server in addition to my Windows setup. This way, I could see how Elastic integrates with both platforms.

16. **Observed a Failed Login Attempt from a Malicious IP**  
    - This was a key learning moment. Even though I had just set things up, I already spotted a failed login attempt, which was a great reminder of how critical it is to keep an eye on logs.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2032%20looking%20at%20failed%20logon%20attempts%20already.PNG)

17. **Installed Elastic Agent on the Ubuntu Server**  
    - Installing Elastic Agent on Ubuntu was a breeze after my Windows experience. This tool is crucial for collecting endpoint data.

18. **Created a New Policy for Linux Endpoint**  
    - I created a dedicated policy for my Linux server to ensure all Linux-related events were properly monitored.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2033%20We%20are%20going%20to%20create%20a%20new%20agent%20policy.PNG)

19. **Reviewed Logs to be Ingested from the Linux Endpoint**  
    - Reviewing logs before fully integrating them helps you stay on top of what’s being ingested, and ensures you aren’t overwhelmed by unnecessary data.  
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2034%20We%20can%20see%20here%20what%20logs%20we%20are%20ingesting%20for%20linux%20endpoints.PNG)

20. **Added a New Agent and Executed the Curl Script**  
    - I used a self-signed certificate for this project, so I ran the curl script with `--insecure`. Be careful with self-signed certificates, but for lab environments like this, it’s perfectly fine

21. **Agent Successfully Connected!**  
    - Finally, I got the agent connected. Everything came together 
    ![image](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2036%20Looking%20good!%20Our%20agent%20has%20been%20connected.PNG)


22. Setting Up Logging and Monitoring
   - **Verifying Log Ingestion**: After setting up log collection from various servers, I checked to ensure that logs were being successfully ingested. Confirmed logs are being received!
  ![Log Ingestion Verification](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2037%20seeing%20if%20we%20are%20successfully%20getting%20those%20logs.PNG) <!-- Replace with actual image link -->

23. SSH Brute Force Alerts
   - **Creating SSH Brute Force Alerts**: Set up alerts to detect brute force attempts for SSH logins. This includes tracking failed logins and failed password attempts.
   - **Search for Failed Login Attempts**: Created a custom query to identify failed SSH login attempts with additional information such as source IP and user account.
  ![Failed SSH Login Query](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2038%20Setting%20up%20a%20query%20in%20our%20data%20to%20filter%20Failed%20login%20attempts%2C%20include%20IP%2C%20username%2C%20and%20region%20used.PNG) <!-- Replace with actual image link -->

24. Creating Custom Detection Rules
   - **Saved Search for Rule Creation**: Saved the search for failed SSH login attempts and proceeded to create a new detection rule based on this search.
  ![Saving Search for Rule](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2039%20You%20can%20save%20your%20searches%2C%20Save%20it%20and%20then%20create%20an%20alert.PNG) <!-- Replace with actual image link -->
   - **Alert Creation**: I created a custom rule based on this query. This rule will generate alerts for failed login attempts, although it's not ideal for production as it might generate excessive alerts. The goal was to get some sample data for my project.
  ![Custom Rule Setup](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2040%20Creating%20the%20query%20rule%2C%20and%20implementing%20it.PNG) <!-- Replace with actual image link -->

25. Dashboard Creation Completed
   - **Final Dashboard**: The dashboard, now containing both failed and successful login visualizations, was successfully created and is fully operational.
  ![Final SSH Dashboard](https://github.com/Jacob-Brown-950/30-Day-SOC-Challenge/blob/main/Screenshots/Step%2042%20Dashboard%20Successfully%20Created.PNG) <!-- Replace with actual image link -->

